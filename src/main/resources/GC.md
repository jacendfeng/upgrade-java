# GC
## 辨别那些是垃圾
引用计数器 -- 循环计数器
可达性分析
那么什么是 GC Roots 呢？我们可以暂时理解为由堆外指向堆内的引用，
一般而言，GC Roots 包括（但不限于）如下几种：
- Java 方法栈桢中的局部变量；
- 已加载类的静态变量；
- JNI handles；
- 已启动且未停止的 Java 线程。

如何解决循环引用
可达性分析可以解决引用计数法所不能解决的循环引用问题。
举例来说，即便对象 a 和 b 相互引用，只要从 GC Roots 
出发无法到达 a 或者 b，那么可达性分析便不会将它们加入存活对象合集之中。

标记
目前 Java 虚拟机的主流垃圾回收器采取的是可达性分析算法。
这个算法的实质在于将一系列 GC Roots 作为初始的存活对象合集（live set），
然后从该合集出发，探索所有能够被该集合引用到的对象，并将其加入到该集合中，
这个过程我们也称之为标记（mark）。最终，未被探索到的对象便是死亡的，是可以回收的。


## Stop-the-world 以及安全点
举个例子，当 Java 程序通过 JNI 执行本地代码时，
如果这段代码不访问 Java 对象、调用 Java 方法或者返回至原 
Java 方法，那么 Java 虚拟机的堆栈不会发生改变，也就代表着这段本地代码可以作为同一个安全点。

## 垃圾回收的三种方式
当标记完所有对象之后  
标记 - 清理
标记 - 压缩
标记 - 复制

基于 Java 对象生命周期的研究

# 分代垃圾回收
之所以要提到这个假设，是因为它造就了 Java 虚拟机的分代回收思想。
简单来说，就是将堆空间划分为两代，分别叫做新生代和老年代。
新生代用来存储新建的对象。当对象存活时间够长时，则将其移动到老年代。
Java 虚拟机可以给不同代使用不同的回收算法。
对于新生代，我们猜测大部分的 Java 对象只存活一小段时间，
那么便可以频繁地采用耗时较短的垃圾回收算法，让大部分的垃圾都能够在新生代被回收掉。
对于老年代，我们猜测大部分的垃圾已经在新生代中被回收了，而在老年代中的对象有大概率会继续存活。
当真正触发针对老年代的回收时，则代表这个假设出错了，或者堆的空间已经耗尽了。
这时候，Java 虚拟机往往需要做一次全堆扫描，耗时也将不计成本。
（当然，现代的垃圾回收器都在并发收集的道路上发展，来避免这种全堆扫描的情况。）


## 避免线程之间分配内存需要频繁的同步开销
TLAB（Thread Local Allocation Buffer）对应虚拟机参数 -XX:+UseTLAB，默认开启

Minor GC 的另外一个好处是不用对整个堆进行垃圾回收。
但是，它却有一个问题，那就是老年代的对象可能引用新生代的对象。
也就是说，在标记存活对象的时候，我们需要扫描老年代中的对象。
如果该对象拥有对新生代对象的引用，那么这个引用也会被作为 GC Roots。

## 卡表 Card Table
HotSpot 给出的解决方案是一项叫做卡表（Card Table）的技术。
该技术将整个堆划分为一个个大小为 512 字节的卡，并且维护一个卡表，
用来存储每张卡的一个标识位。这个标识位代表对应的卡是否可能存有指向新生代对象的引用。
如果可能存在，那么我们就认为这张卡是脏的。

在进行 Minor GC 的时候，我们便可以不用扫描整个老年代，
而是在卡表中寻找脏卡，并将脏卡中的对象加入到 Minor GC 的 GC Roots 里。
当完成所有脏卡的扫描之后，Java 虚拟机便会将所有脏卡的标识位清零。

# 典型的垃圾回收器
针对新生代的垃圾回收器共有三个：
Serial，Parallel Scavenge 和 Parallel New。
这三个采用的都是标记 - 复制算法。
其中，Serial 是一个单线程的，
Parallel New 可以看成 Serial 的多线程版本。
Parallel Scavenge 和 Parallel New 类似，但更加注重吞吐率。
此外，Parallel Scavenge 不能与 CMS 一起使用。


针对老年代的垃圾回收器也有三个：
刚刚提到的 Serial Old 和 Parallel Old，
以及 CMS。
Serial Old 和 Parallel Old 都是标记 - 压缩算法。
同样，前者是单线程的，而后者可以看成前者的多线程版本。

CMS 采用的是标记 - 清除算法，
并且是并发的。除了少数几个操作需要 Stop-the-world 之外，
它可以在应用程序运行过程中进行垃圾回收。在并发收集失败的情况下，
Java 虚拟机会使用其他两个压缩型垃圾回收器进行一次垃圾回收。
由于 G1 的出现，CMS 在 Java 9 中已被废弃[3]。


G1（Garbage First）是一个横跨新生代和老年代的垃圾回收器。
实际上，它已经打乱了前面所说的堆结构，直接将堆分成极其多个区域。
每个区域都可以充当 Eden 区、Survivor 区或者老年代中的一个。
它采用的是标记 - 压缩算法，而且和 CMS 一样都能够在应用程序运行过程中并发地进行垃圾回收。

G1 能够针对每个细分的区域来进行垃圾回收。
在选择进行垃圾回收的区域时，它会优先回收死亡对象较多的区域。这也是 G1 名字的由来。